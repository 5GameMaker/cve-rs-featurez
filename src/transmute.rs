//! An implementation of the [`std::mem::transmute`] function, purely in safe Rust.

static UNIT: &'static &() = &&();

fn exploit<'a, 'b, T>(_: &'a &'b (), v: &'b mut T) -> &'a mut T {
	v
}
fn extend_lifetime<'a, T>(x: &'a mut T) -> &'static mut T {
	let f: fn(_, &'a mut T) -> &'static mut T = exploit;
	f(UNIT, x)
}

#[inline(never)]
#[allow(clippy::pedantic)]
fn get_dangling_ref<B>() -> &'static mut &'static mut Option<Box<B>> {
	extend_lifetime(&mut extend_lifetime(&mut None))
}

#[inline(never)]
fn fill_memory<A>(val: &A) {
	std::hint::black_box([&val; 256]);
}

/// Interprets a value of type `A` as a value of type `B`. Equivalent of [`std::mem::transmute`], but implemented in safe code only.
#[allow(clippy::pedantic)]
pub fn transmute<A: Sized + 'static, B: Sized + 'static>(obj: A) -> B {
	let ref_to_box = Box::leak(Box::new(obj));
	let ref_to_b = get_dangling_ref::<B>();
	fill_memory(ref_to_box);
	*ref_to_b.take().unwrap()
}
use std::io::Write;

#[cfg(test)]
mod tests {
	// I'll allow it here.
	#![allow(unsafe_code)]

	#[test]
	#[allow(
		clippy::transmute_float_to_int,
		clippy::unreadable_literal,
		clippy::transmute_num_to_bytes
	)]
	fn test_transmute() {
		use crate::transmute;
		use std::mem;

		unsafe {
			assert_eq!(
				transmute::transmute::<f32, i32>(420.69),
				mem::transmute::<f32, i32>(420.69)
			);
			assert_eq!(
				transmute::transmute::<u32, i32>(0xf0000000),
				mem::transmute::<u32, i32>(0xf0000000)
			);
			assert_eq!(
				transmute::transmute::<f64, [u8; 8]>(123.456),
				mem::transmute::<f64, [u8; 8]>(123.456)
			);
			let my_ref = &42;
			assert_eq!(
				transmute::transmute::<&u8, isize>(my_ref),
				mem::transmute::<&u8, isize>(my_ref)
			);
			assert_eq!(
				transmute::transmute::<[i32; 5], [u8; 20]>([1, 2, 3, 4, 5]),
				mem::transmute::<[i32; 5], [u8; 20]>([1, 2, 3, 4, 5])
			);
		}
	}
}

#[repr(C)]
#[derive(Debug)]
struct Boy {
	age: u32,
	name: String,
	github_username: String,
}
#[repr(C)]
#[derive(Debug)]
struct Girl {
	age: u32,
	name: String,
	github_username: String,
}

pub fn transmute_bin() -> std::io::Result<()> {
	let stdin = std::io::stdin();
	let mut stdout = std::io::stdout();
	let mut input_buf = String::new();

	stdout.write_all(b"Creating a Boy struct\n")?;

	let age = {
		stdout.write_all(b"Enter age: ")?;
		stdout.flush()?;

		stdin.read_line(&mut input_buf)?;

		match input_buf.trim().parse() {
			Ok(age) => age,
			Err(_) => panic!("Invalid age"),
		}
	};

	let name = {
		stdout.write_all(b"Enter name: ")?;
		stdout.flush()?;

		input_buf.clear();
		stdin.read_line(&mut input_buf)?;
		input_buf.trim().to_owned()
	};

	let github_username = {
		stdout.write_all(b"Enter github username: ")?;
		stdout.flush()?;

		input_buf.clear();
		stdin.read_line(&mut input_buf)?;
		input_buf.trim().to_owned()
	};

	let boy: Boy = Boy {
		age,
		name,
		github_username,
	};

	println!("Before transmute: {boy:?}");

	let girl: Girl = transmute(boy);

	println!("After transmute: {girl:?}");

	Ok(())
}
