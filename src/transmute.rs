
/// An implementation of the [`std::mem::transmute`] function, purely in safe Rust.

static UNIT: &'static &() = &&();

fn exploit<'a, 'b, T>(_: &'a &'b (), v: &'b mut T) -> &'a mut T {
    v
}
fn extend_lifetime<'a, T>(x: &'a mut T) -> &'static mut T {
    let f: fn(_, &'a mut T) -> &'static mut T = exploit;
    f(UNIT, x)
}

#[inline(never)]
fn get_dangling_ref<B>() -> &'static mut &'static mut Option<Box<B>> {
    extend_lifetime(&mut extend_lifetime(&mut None))
}

#[inline(never)]
fn fill_memory<A>(val: &A) {
    std::hint::black_box([&val; 256]);
}

/// Interprets a value of type `A` as a value of type `B`. Equivalent of [`std::mem::transmute`], but implemented in safe code only.
pub fn transmute<A: Sized + 'static, B: Sized + 'static>(obj: A) -> B {
    let ref_to_box = Box::leak(Box::new(obj));
    let ref_to_b = get_dangling_ref::<B>();
    fill_memory(ref_to_box);
    *ref_to_b.take().unwrap()
}

#[cfg(test)]
mod tests {
    #![allow(unsafe_code)]

    #[test]
    fn test_transmute() {
        use std::mem;
        use crate::transmute;

        unsafe {
            assert_eq!(transmute::transmute::<f32, i32>(420.69), mem::transmute::<f32, i32>(420.69));
            assert_eq!(transmute::transmute::<u32, i32>(0xf0000000), mem::transmute::<u32, i32>(0xf0000000));
            assert_eq!(transmute::transmute::<f64, [u8; 8]>(123.456), mem::transmute::<f64, [u8; 8]>(123.456));
            let my_ref = &42;
            assert_eq!(transmute::transmute::<&u8, isize>(my_ref), mem::transmute::<&u8, isize>(my_ref));
            assert_eq!(transmute::transmute::<[i32; 5], [u8; 20]>([1, 2, 3, 4, 5]), mem::transmute::<[i32; 5], [u8; 20]>([1, 2, 3, 4, 5]));
        }
    }
}