//! An 100% memory-safe implementation of [`std::mem::transmute`].

/// Interprets a value of type `A` as a value of type `B`. Equivalent of [`std::mem::transmute`], but implemented in safe code.
///
/// # Explanation
///
/// We first acquire a dangling reference to an `Option<Box<B>>`, first initialized to `None`.
/// `Option<Box<B>>` has the same size/alignment as `Box<B>` (because `Box<B>` contains a `Unique<B>`, which can never be null),
///
/// If we can overwrite the referenced location with a `Box<A>`, we can unwrap the `Option` and transmute the data!
/// Unfortunately, we can't fill a range of memory with a `Box<A>`. However, `Box::leak` returns a reference which we can copy, and it turns out that `Box<T>` has the same memory representation as a `&T` acquired from a leaked `Box`!
///
/// So TL;DR: We get a dangling reference to `Option<B>`, overwrite that with a leaked reference to transmute `&A` to `Option<Box<B>>`, then unwrap and deref the box to transmute the object.
#[inline(never)]
pub fn transmute<A: 'static, B: 'static>(obj: A) -> B {
	use std::hint::black_box;

	// The layout of `DummyStruct` is approximately
	// DummyStruct {
	//	   is_a_or_b: u8,
	//     data: usize,
	// }
	enum DummyStruct<A: 'static, B> {
		A(Option<&'static A>),
		B(Option<Box<B>>),
	}

	#[inline(never)]
	fn transmute_inner<A: 'static, B: 'static>(dummy: &mut DummyStruct<A, B>, obj: A) -> B {
		let DummyStruct::B(ref_to_b) = dummy else {
			unreachable!()
		};
		let ref_to_b = crate::lifetime_expansion::expand_mut(ref_to_b);
		*dummy = DummyStruct::A(Some(Box::leak(Box::new(obj))));
		black_box(dummy);

		*ref_to_b.take().unwrap()
	}

	transmute_inner(black_box(&mut DummyStruct::B(None)), obj)
}

#[cfg(test)]
mod tests {
	// I'll allow it here.
	#![allow(unsafe_code)]

	#[test]
	#[allow(clippy::transmute_float_to_int, clippy::transmute_num_to_bytes)]
	fn test_transmute() {
		use crate::transmute;
		use std::mem;

		unsafe {
			assert_eq!(
				transmute::transmute::<f32, i32>(420.69),
				mem::transmute::<f32, i32>(420.69)
			);
			assert_eq!(
				transmute::transmute::<u32, i32>(0xf0000000),
				mem::transmute::<u32, i32>(0xf0000000)
			);
			assert_eq!(
				transmute::transmute::<f64, [u8; 8]>(123.456),
				mem::transmute::<f64, [u8; 8]>(123.456)
			);
			let my_ref = &42;
			assert_eq!(
				transmute::transmute::<&u8, isize>(my_ref),
				mem::transmute::<&u8, isize>(my_ref)
			);
			assert_eq!(
				transmute::transmute::<[i32; 5], [u8; 20]>([1, 2, 3, 4, 5]),
				mem::transmute::<[i32; 5], [u8; 20]>([1, 2, 3, 4, 5])
			);
		}
	}
}
