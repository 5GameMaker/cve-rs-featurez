//! An implementation of the [`std::mem::transmute`] function, purely in safe Rust.

use {crate::lifetime_expansion, std::io::Write};

#[inline(never)]
#[allow(clippy::pedantic)]
fn get_dangling_ref<B>() -> &'static mut Option<Box<B>> {
	lifetime_expansion::expand_mut(&mut None)
}

#[inline(never)]
fn fill_memory<A>(val: &A) {
	std::hint::black_box([val; 256]);
}

/// Interprets a value of type `A` as a value of type `B`. Equivalent of [`std::mem::transmute`],
/// but implemented in safe code only.
#[allow(clippy::pedantic)]
pub fn transmute<A: Sized + 'static, B: Sized + 'static>(obj: A) -> B {
	let ref_to_box = Box::leak(Box::new(obj));
	let ref_to_b = get_dangling_ref::<B>();
	fill_memory(ref_to_box);
	*ref_to_b.take().unwrap()
}

#[repr(C)]
#[derive(Debug)]
struct Boy {
	age: u32,
	name: String,
	github_username: String,
}
#[repr(C)]
#[derive(Debug)]
struct Girl {
	age: u32,
	name: String,
	github_username: String,
}

/// Uses [`transmute`] to convert a [`Boy`] to a [`Girl`].
#[allow(clippy::module_name_repetitions)]
#[allow(clippy::missing_panics_doc)]
pub fn transmute_bin() {
	println!(
		"\
        Source code for this file is available here: \
        https://github.com/Speykious/cve-rs/blob/main/src/transmute.rs
        "
	);

	let stdin = std::io::stdin();
	let mut stdout = std::io::stdout();
	let mut input_buf = String::new();

	stdout.write_all(b"Creating a Boy struct\n").unwrap();

	let age = {
		stdout.write_all(b"Enter age: ").unwrap();
		stdout.flush().unwrap();

		stdin.read_line(&mut input_buf).unwrap();

		input_buf.trim().parse().expect("Invalid age")
	};

	let name = {
		stdout.write_all(b"Enter name: ").unwrap();
		stdout.flush().unwrap();

		input_buf.clear();
		stdin.read_line(&mut input_buf).unwrap();
		input_buf.trim().to_owned()
	};

	let github_username = {
		stdout.write_all(b"Enter github username: ").unwrap();
		stdout.flush().unwrap();

		input_buf.clear();
		stdin.read_line(&mut input_buf).unwrap();
		input_buf.trim().to_owned()
	};

	let boy: Boy = Boy {
		age,
		name,
		github_username,
	};

	println!("Before transmute: {boy:?}");

	let girl: Girl = transmute(boy);

	println!("After transmute: {girl:?}");
}

#[cfg(test)]
mod tests {
	// I'll allow it here.
	#![allow(unsafe_code)]

	#[test]
	#[allow(
		clippy::transmute_float_to_int,
		clippy::unreadable_literal,
		clippy::transmute_num_to_bytes
	)]
	fn test_transmute() {
		use crate::transmute;
		use std::mem;

		unsafe {
			assert_eq!(
				transmute::transmute::<f32, i32>(420.69),
				mem::transmute::<f32, i32>(420.69)
			);
			assert_eq!(
				transmute::transmute::<u32, i32>(0xf0000000),
				mem::transmute::<u32, i32>(0xf0000000)
			);
			assert_eq!(
				transmute::transmute::<f64, [u8; 8]>(123.456),
				mem::transmute::<f64, [u8; 8]>(123.456)
			);
			let my_ref = &42;
			assert_eq!(
				transmute::transmute::<&u8, isize>(my_ref),
				mem::transmute::<&u8, isize>(my_ref)
			);
			assert_eq!(
				transmute::transmute::<[i32; 5], [u8; 20]>([1, 2, 3, 4, 5]),
				mem::transmute::<[i32; 5], [u8; 20]>([1, 2, 3, 4, 5])
			);
		}
	}
}
