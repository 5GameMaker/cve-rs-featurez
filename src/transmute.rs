//! An implementation of the [`std::mem::transmute`] function, purely in safe Rust.

#[inline(never)]
#[allow(clippy::pedantic)]
fn get_dangling_ref<B>() -> &'static mut Option<Box<B>> {
	crate::expand_mut(&mut None)
}

#[inline(never)]
fn fill_memory<A>(val: &A) {
	std::hint::black_box([val; 256]);
}

/// Interprets a value of type `A` as a value of type `B`. Equivalent of [`std::mem::transmute`], but implemented in safe code only.
///
/// ## Explanation
/// We first acquire a dangling reference to an `Option<Box<B>>`, first initialized to `None`.
/// `Option<Box<B>>` has the same size/alignment as `Box<B>` (because `Box<B>` contains a `Unique<B>`, which can never be null),
///
/// If we can overwrite the referenced location with a `Box<A>`, we can unwrap the `Option` and transmute the data!
/// Unfortunately, we can't fill a range of memory with a `Box<A>`. However, `Box::leak` returns a reference which we can copy, and it turns out that `Box<T>` has the same memory representation as `&T`!
///
/// So TL;DR: We get a dangling reference to `Option<B>`, overwrite that with a leaked reference to transmute `&A` to `Option<Box<B>>`, then unwrap and deref the box to transmute the object.
#[allow(clippy::pedantic)]
pub fn transmute<A: Sized + 'static, B: Sized + 'static>(obj: A) -> B {
	let ref_to_box = Box::leak(Box::new(obj));
	let ref_to_b = get_dangling_ref::<B>();
	fill_memory(ref_to_box);
	*ref_to_b.take().unwrap()
}

#[cfg(test)]
mod tests {
	// I'll allow it here.
	#![allow(unsafe_code)]

	#[test]
	#[allow(
		clippy::transmute_float_to_int,
		clippy::unreadable_literal,
		clippy::transmute_num_to_bytes
	)]
	fn test_transmute() {
		use crate::transmute;
		use std::mem;

		unsafe {
			assert_eq!(
				transmute::transmute::<f32, i32>(420.69),
				mem::transmute::<f32, i32>(420.69)
			);
			assert_eq!(
				transmute::transmute::<u32, i32>(0xf0000000),
				mem::transmute::<u32, i32>(0xf0000000)
			);
			assert_eq!(
				transmute::transmute::<f64, [u8; 8]>(123.456),
				mem::transmute::<f64, [u8; 8]>(123.456)
			);
			let my_ref = &42;
			assert_eq!(
				transmute::transmute::<&u8, isize>(my_ref),
				mem::transmute::<&u8, isize>(my_ref)
			);
			assert_eq!(
				transmute::transmute::<[i32; 5], [u8; 20]>([1, 2, 3, 4, 5]),
				mem::transmute::<[i32; 5], [u8; 20]>([1, 2, 3, 4, 5])
			);
		}
	}
}
