//! A 100% memory-safe segmentation fault.
//!
//! We use this hole to create a `'static` reference to a dropped (yes, dropped) `Box<Box<u8>>`.
//!
//! The smart pointer exists on the stack, but was dropped, so the reference
//! is borrowing arbitrary data on the stack. We can then fill the stack with zeros, which
//! replaces the smart pointer's address with zero, creating a null reference in safe Rust.
//!
//! By accessing the contents of the pointer, we force Rust to dereference the null pointer,
//! causing a segfault.
//!
//! > **Note:** In theory this should work with a normal box, but in practice Rust reads random
//! > memory instead of segfaulting on a null pointer. We think this is due to compiler
//! > optimisations.

use std::hint::black_box;

use crate::lifetime_expansion;

/// Returns a static reference to a dropped (yes, dropped) [`Box`].
#[inline(never)]
#[allow(clippy::borrowed_box)]
fn get_dropped_box() -> &'static Box<Box<u8>> {
	let box_ = black_box(Box::new(Box::new(0_0)));
	lifetime_expansion::expand(&box_)
}

/// Segfaults the program.
///
/// In theory this should work with a normal box, but in practice Rust reads random
/// memory instead of segfaulting on a null pointer. We think this is due to compiler
/// optimisations.
pub fn segfault() {
	let my_ref = get_dropped_box();
	black_box([0; 1024]);
	println!("{my_ref:?}");
}
