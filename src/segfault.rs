//! A 100% memory-safe segmentation fault.
//!
//! We use the soundness hole to create a mutable null reference to a `u8`.
//!
//! The smart pointer exists on the stack, but was dropped, so the reference
//! is borrowing arbitrary data on the stack. We can then fill the stack with zeros, which
//! replaces the smart pointer's address with zero, creating a null reference in safe Rust.
//!
//! By accessing the contents of the pointer, we force Rust to dereference the null pointer,
//! causing a segfault.
//!
//! > **Note:** In theory this should work with a normal box, but in practice Rust reads random
//! > memory instead of segfaulting on a null pointer. We think this is due to compiler
//! > optimisations.

/// Segfaults the program.
pub fn segfault() -> ! {
	let null = crate::null_mut::<u8>();
	*null = 42;

	// WASM. u_u
	unreachable!("Sorry, your platform is too strong.")
}

#[cfg(test)]
mod tests {
	#[test]
	fn test_segfault() {
		use std::process::Command;
		let output = Command::new("cargo")
			.arg("run")
			.arg("segfault")
			.output()
			.unwrap();

		if output.status.success()
			|| std::str::from_utf8(&output.stderr)
				.unwrap()
				.contains("Sorry, your platform is too strong.")
		{
			panic!("Segfault failed to segfault");
		}
	}
}
