//! A memory-safe segmentation fault.
//!
//! We use a soundness hole in lifetimes to cast an arbitrary lifetime to 'static.
//! See <https://github.com/rust-lang/rust/issues/25860>.
//!
//! We use this hole to create a 'static reference to a dropped (yes, dropped) smart
//! pointer. The smart pointer exists on the stack, but was dropped, so the reference
//! is borrowing arbitrary data on the stack. We can then fill the stack with 0s, which
//! replaces the smart pointer's address with 0, creating a null pointer in safe Rust.
//! By accessing the contents of the pointer, we force Rust to dereference the null pointer,
//! causing a segfault.

use std::hint::black_box;

/// Arbitrary data with a static lifetime.
static UNIT: &&() = &&();

/// Converts lifetime `'b` to lifetime `'a`.
#[inline(never)]
const fn lifetime_translator<'a, 'b, T>(_: &'a &'b (), v: &'b T) -> &'a T {
    v
}

/// Uses `liftime_translater` and our static `UNIT`'s lifetime to cast an arbitrary
/// lifetime to `'static`.
#[inline(never)]
fn lifetime_exploit<'a, T>(x: &'a T) -> &'static T {
    let f: fn(_, &'a T) -> &'static T = lifetime_translator;
    f(UNIT, x)
}

/// Returns a static reference to a dropped (yes, dropped) box.
#[inline(never)]
#[allow(clippy::borrowed_box)]
fn get_dropped_box() -> &'static Box<Box<u8>> {
    let box_ = black_box(Box::new(Box::new(8)));
    lifetime_exploit(&box_)
}

/// Gets a reference to a dropped smart pointer, then fills the stack with 0s.
/// This overrides where the smart pointer used to be and replaces its address
/// with all 0s, creating a null pointer. We then read the data from the box,
/// which forces Rust to dereference the smart pointer, causing it to dereference
/// a null pointer.
///
/// In theory this should work with a normal box, but in practice Rust reads random
/// memory instead of segfaulting on a null pointer. We think this is due to compiler
/// optimisations.
pub fn segfault() {
    println!("Source code for this segfault");
    println!("=============================");
    println!("{}", include_str!("./segfault.rs"));
    println!("=============================\n");

    let my_ref = get_dropped_box();
    black_box([0; 1024]);
    println!("{my_ref:?}");
}
