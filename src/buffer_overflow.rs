//! A memory-safe buffer overflow.
//!
//! We use a soundness hole in lifetimes to cast an arbitrary lifetime to 'static.
//! See <https://github.com/rust-lang/rust/issues/25860>.
//!
//! We allocate a 10-byte slice on the heap, full of zeroes, then use the soundness
//! hole to obtain a mutable, 'static reference to it, and drop it. We then allocate
//! a new 5-byte slice on the heap, full of ones, and print the contents of it and the
//! old slice. We then write 3s to the original 10-byte slice and once again print
//! the contents of both slices, proving that we wrote out of bounds on the 5-byte slice.
//!
//! This completely memory safe, not-an-exploit works because the two smart pointers
//! to two different buffers get placed at the same location. The first gets dropped,
//! but we maintain a reference to it. When we create the second smart pointer, it
//! gets placed at the same location the first pointer used to be at, meaning our reference
//! now points to the new buffer. The reference stores the size of the old buffer -
//! 10 bytes - meaning when we write to all the bytes from our reference, we write
//! 10 bytes to our 5 byte buffer.

use std::hint::black_box;

/// Arbitrary data with a static lifetime.
static UNIT: &&() = &&();

/// Converts lifetime `'b` to lifetime `'a`.
#[inline(never)]
fn lifetime_translator<'a, 'b, T>(_: &'a &'b (), v: &'b mut T) -> &'a mut T {
	v
}

/// Uses `liftime_translater` and our static `UNIT`'s lifetime to cast an arbitrary
/// lifetime to `'static`.
#[inline(never)]
fn lifetime_exploit<'a, T>(x: &'a mut T) -> &'static mut T {
	let f: fn(_, &'a mut T) -> &'static mut T = lifetime_translator;
	f(UNIT, x)
}

/// Uses the lifetime exploit to obtain a 'static mutable reference to a dropped
/// box, which points to a 10-byte slice.
///
/// This has to be in its own function and not aligned, because otherwise the
#[inline(never)]
#[allow(clippy::borrowed_box)]
fn get_dropped_buffer() -> &'static mut Box<[u8; 10]> {
	let mut original_buffer = black_box(Box::new([0; 10]));
	black_box(lifetime_exploit(&mut original_buffer))
}

/// We create a 'static reference to a dropped, 10-byte buffer, then create a 5-byte
/// buffer in its place. By writing to the buffer from our old reference, Rust thinks
/// the buffer is still 10 bytes, and writes 10 bytes to our 5-byte buffer.
pub fn buffer_overflow() {
	let buffer_ref = get_dropped_buffer();
	let new_buffer = black_box(Box::new([1_u8; 5]));
	println!(
		"Before write:\nNew buffer (small): {new_buffer:?}\nOld buffer (large): {buffer_ref:?}"
	);

	for byte in buffer_ref.iter_mut() {
		*byte = 3;
	}

	println!(
		"After write:\nNew buffer (small): {new_buffer:?}\nOld buffer (large): {buffer_ref:?}"
	);
}
