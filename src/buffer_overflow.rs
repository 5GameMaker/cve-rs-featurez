//! Behold, a perfectly memory-safe buffer overflow!
//!
//! It exploits a soundness hole in lifetimes that lets us promote
//! a scoped reference to a static one, thereby creating a dangling reference.
//!
//! See <https://github.com/rust-lang/rust/issues/25860>

use std::hint::black_box;
use std::io::{stdin, stdout, Read, Write};

static UNIT: &'static &() = &&();

fn exploit<'a, 'b, T>(_: &'a &'b (), v: &'b mut T) -> &'a mut T {
    v
}

fn horrible<'a, T>(x: &'a mut T) -> &'static mut T {
    let exploit: fn(_, &'a mut T) -> &'static mut T = exploit;
    exploit(UNIT, x)
}

const HORRIBLE_LEN: usize = 128;

#[inline(never)]
fn get_horrible_buffer_mut() -> &'static mut [u8; HORRIBLE_LEN] {
    let mut buffer = black_box([0; HORRIBLE_LEN]);
    horrible(&mut buffer)
}

#[inline(never)]
fn innocent_prompt() {
    print!("Give text (only {HORRIBLE_LEN} chars will be read) > ");
    stdout().flush().unwrap();
}

#[inline(never)]
fn innocent_read(initial_buffer_mut: &mut [u8; HORRIBLE_LEN]) {
    let mut stdin = black_box(stdin());

    innocent_prompt();

    let buffer = black_box([0_u8; HORRIBLE_LEN / 2]);

    // "Nah, I'd win." - Rust compiler
    stdin.read_exact(initial_buffer_mut).unwrap();

    println!("Completely safe buffer (it only has zeros in it I promise): {buffer:?}");
}

/// Create a buffer and overwrite it
pub fn buffer_overflow() {
    println!("Source code for this buffer overflow");
    println!("====================================");
    println!("{}", include_str!("./buffer_overflow.rs"));
    println!("====================================\n");

    let initial_buffer_mut = get_horrible_buffer_mut();
    innocent_read(initial_buffer_mut);
}
