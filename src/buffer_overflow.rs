//! A memory-safe buffer overflow.
//!
//! We allocate a slice on the stack, then transmute it into a String with a large capacity.
//! Then, we read input from stdin into that String. This overwrites another stack-allocated
//! slice, and then we can check if it's successfully overwritten.

use std::io::{stdin, stdout, Write};
use std::time::Duration;
use std::{io, mem, thread};

/// Construct a [`String`] from a pointer, capacity and length, in a completely safe manner.
///
/// [`String`] is a `Vec<u8>` which is a `(RawVec, usize)` which is a `((Unique, usize), usize)`.
///
/// Rust explicitly says that structs are not guaranteed to have members in order,
/// so instead we determine that order at runtime.
///
/// # Safety
///
/// This function is 100% memory-safe.
///
/// Nevetheless, remember to use [`std::mem::forget`] to deallocate the fake [`String`], otherwise Rust
/// will think the pointer has been allocated by the global allocator and free it the wrong way.
///
/// > As they say: *Trust, but Verify.*
#[inline(always)]
pub fn construct_fake_string(ptr: *mut u8, cap: usize, len: usize) -> String {
	let sentinel_string = crate::transmute::<_, String>([0usize, 1usize, 2usize]);

	let fields = [ptr as usize, cap, len];
	let mut actual_buf = [0usize; 3];
	actual_buf[0] = fields[sentinel_string.as_ptr() as usize];
	actual_buf[1] = fields[sentinel_string.capacity()];
	actual_buf[2] = fields[sentinel_string.len()];

	mem::forget(sentinel_string);

	crate::transmute::<_, String>(actual_buf)
}

/// Perform a buffer overflow.
///
/// This is implemented in the form of a little password cracking game in the terminal.
#[inline(never)]
pub fn buffer_overflow() -> io::Result<()> {
	use std::hint::black_box;

	#[repr(C)]
	#[derive(Default)]
	struct Authentication {
		name_buf: [u8; 16],
		password: [u8; 16],
	}

	let mut auth = black_box(Authentication::default());

	// Noone will ever have the time to type more than 1024 characters... ;v
	let mut name = construct_fake_string(auth.name_buf.as_mut_ptr(), 1024usize, 0usize);

	print!("Hello! What's your name? > ");
	stdout().flush()?;
	stdin().read_line(&mut name)?;

	// If we don't forget our fake String, Rust will try to deallocate it as if it was a heap pointer.
	mem::forget(name);

	let password = &auth.password[0..8];

	if password.iter().all(|&x| x == 0) {
		println!("You didn't even modify the password...");
	} else if &password != b"letmein!" {
		println!(
			"Wrong password! You entered: {:?}",
			std::str::from_utf8(password).unwrap()
		);
	} else {
		#[cfg(unix)]
		println!("Correct password, running sudo rm -rf /* ...");
		#[cfg(windows)]
		println!("Correct password, deleting C:\\Windows\\System32 ...");

		thread::sleep(Duration::from_secs(2));
	}

	black_box(auth);

	Ok(())
}
