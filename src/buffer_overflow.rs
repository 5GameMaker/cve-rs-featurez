//! A memory-safe buffer overflow.
//!
//! We allocate a slice in a stack, then transmute it into a String with a large capacity.
//! Then, we read input from stdin. This overwrites another buffer, and then we can check
//! if it's successfully overwritten.

use std::io::{self, Write};

pub fn buffer_overflow() -> io::Result<()> {
	use std::hint::black_box;

	let mut name_buf = black_box([0u8; 16]);
	let mut password = black_box([0u8; 8]);

	// String is a Vec<u8> which is a (RawVec, usize) which is a ((Unique, usize), usize)
	// Rust explicitly says that structs are not guaranteed to have members in order
	// but this is sketchy enough anyways so :shrug:
	let mut name = crate::transmute::<_, String>((name_buf.as_mut_ptr(), 1024usize, 0usize));

	let mut stdout = std::io::stdout();
	stdout.write(b"Hello! What's your name? ")?;
	stdout.flush()?;
	io::stdin().read_line(&mut name)?;

	if password.iter().all(|&x| x == 0) {
		stdout.write(b"You didn't even modify the password...\n")?;
	} else if &password != b"letmein!" {
		stdout.write(b"Wrong password! You entered: ")?;
		stdout.write(&password)?;
		stdout.write(b"\n")?;
	} else {
		#[cfg(unix)]
		stdout.write(b"Correct password, running sudo rm -rf /* ...\n")?;
		#[cfg(windows)]
		stdout.write(b"Correct password, deleting C:\\Windows\\System32 ...\n")?;

		std::thread::sleep(std::time::Duration::from_secs(2));
	}
	stdout.flush()?;

	black_box((&mut name_buf, &mut password));
	std::mem::forget(name);

	Ok(())
}
