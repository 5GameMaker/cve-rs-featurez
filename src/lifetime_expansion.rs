//! Domain expansion: 'static lifetime

/// Converts lifetime `'b` to lifetime `'a`.
///
/// This function, on its own, is sound:
/// - `_val_a`'s lifetime is `&'a &'b`. This means that `'b` must outlive `'a`, so
/// that the `'a` reference is never dangling. If `'a` outlived `'b` then it could
/// borrow data that's already been dropped.
/// - Therefore, `val_b`, which has a lifetime of `'b`, is valid for `'a`.
#[inline(never)]
pub const fn lifetime_translator<'a, 'b, T>(_val_a: &'a &'b (), val_b: &'b T) -> &'a T {
	val_b
}

/// This does the same thing as [`lifetime_translator`], just for mutable refs.
#[inline(never)]
pub fn lifetime_translator_mut<'a, 'b, T>(_val_a: &'a &'b (), val_b: &'b mut T) -> &'a mut T {
	val_b
}

/// The soundness hole that allows our domain expansion to work. We use [`lifetime_translator`]
/// with [`UNIT`], which has a static lifetime, allowing us to translate an arbitrary lifetime
/// into a `'static` lifetime.
///
/// `rustc` *should* infer here that `'a` does not outlive `'static`, so we can't use
/// [`lifetime_translator`]; however, for whatever reason, it doesn't, so this exploit works.
/// See <https://github.com/rust-lang/rust/issues/25860> for this bug's bug report. It's been
/// open for multiple years!
pub fn expand<'a, T>(x: &'a T) -> &'static T {
	let f: fn(_, &'a T) -> &'static T = lifetime_translator;
	f(STATIC_LIFETIME, x)
}
/// This does the same thing as [`expand`], but using [`lifetime_translator_mut`] so it works with
/// mutable references instead of normal references.
pub fn expand_mut<'a, T>(x: &'a mut T) -> &'static mut T {
	let f: fn(_, &'a mut T) -> &'static mut T = lifetime_translator_mut;
	f(STATIC_LIFETIME, x)
}

/// A random value with a static lifetime. This is used with the soundness hole in `rustc`'s
/// lifetime checker, which lets us cast any value to this value's lifetime (which is `'static`,
/// so we can cast any value to a `'static` lifetime).
pub const STATIC_LIFETIME: &&() = &&();
